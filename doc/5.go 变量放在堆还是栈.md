# go 变量放在堆还是栈

编译器会自动选择在栈上还是在堆上分配局部变量的存储空间
<br>

```java
var global * int

func f() {
    var x int
    x = 1
    global = &x
}

func g() {
    y := new(int)
    *y = 1
}
```
<br>

f() 函数的 x变量必须在堆上分配，因为函数退出后，仍然可以通过 global 变量获取。
<br>
用 go 的术语说，这个x局部变量从函数 f() 中逃逸了。


g（）函数返回的时候，变量 *y将不可达到，也就是马上被回收的，*y并没有

从函数g中逃逸，编译器可以选择在栈上分配*y的存储空间。

<br>
（注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间。

注意：你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。


总结：Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期。
例如：如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）。

